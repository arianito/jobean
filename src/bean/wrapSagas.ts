import {put, call, cancelled, select} from 'redux-saga/effects'
import {AnyAction} from "redux";
import {BeanFactory} from "./BeanFactory";
import {ActAction, ActStatus} from "./Act";


// wrap any generator function into single saga scoped operation
// server side used to set server side flag to prevent user to reload server initialized data
export const wrapSagas = function* (payload: ActAction<any> & AnyAction, procedure, server?: boolean) {
	const action = BeanFactory.decompose(payload.type);

	// we dont want to store cookies or any sensitive data inside store
	const objs = {...payload};
	delete objs.done;
	delete objs.cookies;

	try {
		// first we call out body, the body takes the user payload and old stored operation payload
		// and it provides a new new result for operation
		const operation = (yield select(state => state[action.bean][action.act])) || {};
		const result = (yield* procedure({
			...payload,
			operation,
		})) || null;

		// pass the result to reducer

		yield put({
			type: BeanFactory.compose(action.bean, action.act, ActStatus.succeed),
			result,
			payload: objs,
			server,
		});

		// call done function effect payload
		if (payload.done) {
			yield call(payload.done, true, result)
		}
	} catch (result) {
		// pass the error generated by body into reducer

		yield put({
			type: BeanFactory.compose(action.bean, action.act, ActStatus.failed),
			result,
			payload: objs,
			server,
		});

		// call done function effect error
		if (payload.done) {
			yield call(payload.done, false, result)
		}
	} finally {
		// handle cancelled acts
		if (yield cancelled()) {
			yield put({
				type: BeanFactory.compose(action.bean, action.act, ActStatus.canceled),
				result: null,
				payload: objs,
				server,
			});
			if (payload.done) {
				yield call(payload.done, null, null)
			}
		}
	}
};
